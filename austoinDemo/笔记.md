# Go模块管理笔记

> 记录日期：2026-02-06
> 适用场景：本地开发、跨目录模块调用

---

## 一、核心概念

### 1.1 模块（Module）是什么？

**模块 = 项目 = 一个 `go.mod` 文件**

| 概念 | 说明 |
|-----|------|
| 模块 | Go依赖管理的基本单位 |
| go.mod | 模块声明文件，记录模块名、版本、依赖 |
| go.sum | 依赖校验文件，确保依赖1.2 包安全 |

### （Package）是什么？

**包 = 目录 = 一组 `.go` 文件**

| 规则 | 说明 |
|-----|------|
| 同一目录 | 同一包，直接调用 |
| 不同目录 | 不同包，需要导入 |
| 包名 | 目录名或自定义，通常与目录名一致 |

---

## 二、本地模块开发

### 2.1 问题背景

正常情况下，Go期望从**远程仓库**下载模块：
```
import "github.com/用户名/项目名/子目录"
```

但开发阶段代码在**本地**，没有上传GitHub。

### 2.2 解决方案：replace 指令

**作用**：告诉Go"这个模块虽然在远程路径里，但实际上在本地"

#### 配置步骤

**步骤1：根目录执行初始化（只需一次）**
```bash
cd GolangTutorial
go mod init github.com/austoin/golangtutorial
```

**步骤2：在go.mod中添加replace指令**
```go
module github.com/austoin/golangtutorial

go 1.25.6

replace 远程路径 => 本地路径
```

**步骤3：编写调用代码**
```go
package main

import (
    别名 "远程路径"
)

func main() {
    别名.公开函数()
}
```

---

## 三、实战：austoinDemo/A-base 调用示例

### 3.1 目录结构

```
GolangTutorial/
├── go.mod                    ← 根模块
│
├── austoinDemo/
│   ├── main.go               ← 主程序（调用方）
│   └── A-base/               ← 子包（被调用方）
│       ├── 1.go
│       ├── 2.go
│       └── ...
```

### 3.2 被调用方：A-base/*.go

```go
// A-base/1.go
package lesson  // 包名

func Lesson1() {  // 首字母大写 = 公开，可被其他包访问
    fmt.Println("Hello, World!")
}
```

**关键点**：
- 包名：`lesson`（与目录名无关，可自定义）
- 函数名：`Lesson1()` 首字母大写（公开）
- 同目录下其他文件也需要 `package lesson`

### 3.3 调用方：main.go

```go
// austoinDemo/main.go
package main

import (
    abaselib "github.com/austoin/golangtutorial/austoinDemo/A-base"
)

func main() {
    abaselib.Lesson1()
}
```

**关键点**：
- 导入路径 = 模块路径 + 子目录路径
- 使用别名避免冲突：`abaselib` 是别名
- 调用方式：`别名.公开函数()`

### 3.4 根目录：go.mod

```go
module github.com/austoin/golangtutorial

go 1.25.6

replace github.com/austoin/golangtutorial/austoinDemo/A-base => ./austoinDemo/A-base
```

**关键点**：
- `replace` 指令将远程路径映射到本地路径
- `=>` 左边是远程路径，右边是本地路径

---

## 四、远程模块调用

### 4.1 调用第三方库

```go
package main

import (
    "github.com/gin-gonic/gin"  // Web框架
    "gorm.io/gorm"              // ORM库
    "github.com/redis/go-redis/v9"  // Redis客户端
)

func main() {
    // 使用第三方库
    r := gin.Default()
    r.GET("/", func(c *gin.Context) {
        c.String(200, "Hello!")
    })
    r.Run()
}
```

### 4.2 下载依赖

```bash
go mod tidy
```

**作用**：
1. 扫描代码中的 `import`，识别使用的依赖
2. 下载依赖到本地
3. 自动更新 `go.mod` 和 `go.sum`

---

## 五、go.mod 详解

### 5.1 最小配置

```go
module 模块名

go 版本号
```

### 5.2 完整配置

```go
module github.com/用户名/项目名

go 1.25.6

require (
    第三方库1 v1.0.0
    第三方库2 v2.0.0
)

replace 本地路径 => 远程路径

replace 本地路径 => ./本地子目录
```

### 5.3 常用命令

| 命令 | 作用 |
|-----|------|
| `go mod init 模块名` | 初始化模块（创建go.mod） |
| `go mod tidy` | 下载依赖，更新go.mod/go.sum |
| `go mod download` | 下载所有依赖 |
| `go get 包名@版本` | 下载指定包 |
| `go env -w GOPROXY=...` | 设置代理（国内用goproxy.cn） |

---

## 六、常见问题

### Q1: 相对路径导入报错？

**错误**：
```
local import "./A-base" in non-local package
```

**原因**：Go 1.16+ 不支持相对路径导入

**解决**：使用模块路径 + replace 指令

### Q2: ambiguous import？

**错误**：
```
found package in multiple modules
```

**原因**：
- 模块在主模块和子模块中都存在
- 重复的 require 声明

**解决**：
1. 删除子目录的独立 go.mod
2. 清理根目录 go.mod 中多余的 require

### Q3: 找不到包？

**错误**：
```
cannot find package
```

**原因**：
- 没有运行 `go mod tidy`
- replace 路径错误

**解决**：
```bash
go mod tidy
# 检查 replace 路径是否正确
```

---

## 七、可见性规则

### 7.1 函数/变量可见性

```go
package lesson

func PublicFunc() {}    // ✅ 首字母大写 = 公开，其他包可访问

func privateFunc() {}   // ❌ 首字母小写 = 私有，其他包不可访问
```

### 7.2 结构体可见性

```go
package lesson

type PublicStruct struct {  // ✅ 公开
    Name string  // 字段也可以控制可见性
}

type privateStruct struct {  // ❌ 私有
    age int
}
```

---

## 八、接口与隐式实现

### 8.1 什么是接口？

**接口 = 方法签名的集合**，定义对象应该具备什么行为。

```go
// 定义接口
type Introducer interface {
    Introduce() string  // 要求实现这个方法
}
```

### 8.2 隐式实现（Go的特性）

**在Go中，接口是隐式实现的**——不需要显式声明"我实现了这个接口"。

只要结构体拥有接口中定义的所有方法，它就**自动**实现了该接口。

```go
// 1. 定义接口
type Introducer interface {
    Introduce() string
}

// 2. 定义结构体
type Person struct {
    Name string
    Age  int
}

// 3. 结构体拥有接口要求的方法
func (p Person) Introduce() string {
    return fmt.Sprintf("我叫%s，今年%d岁", p.Name, p.Age)
}

// 4. 因此 Person 自动实现了 Introducer 接口
//    不需要像 Java 那样写：class Person implements Introducer
```

### 8.3 原理：鸭子类型

> "如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子"

```
Person 有 Introduce() 方法
        ↓
自动满足 Introducer 接口
        ↓
Person 的对象可以当作 Introducer 使用
```

### 8.4 接口的实际应用

```go
// 接口可以存储任何实现了该接口的类型
var greeter Introducer

p1 := Person{Name: "Eve", Age: 32}
greeter = p1  // ✅ 可以，因为 Person 实现了 Introducer

fmt.Printf("%s\n", greeter.Introduce())

// 遍历实现接口的对象
people := []Person{
    {Name: "Charlie", Age: 35},
    {Name: "Diana", Age: 28},
}

for _, p := range people {
    fmt.Printf("%s 说: %s\n", p.Name, p.Introduce())
}
```

### 8.5 空接口 interface{}

空接口可以存储**任意类型**：

```go
var anything interface{}

anything = 42
fmt.Printf("anything: %v\n", anything)  // 42

anything = "hello"
fmt.Printf("anything: %v\n", anything)  // hello

anything = []int{1, 2, 3}
fmt.Printf("anything: %v\n", anything)  // [1 2 3]
```

### 8.6 对比：显式 vs 隐式实现

| 语言 | 实现方式 |
|-----|---------|
| **Go** | 隐式（自动） |
| Java | 显式 (`class Person implements Introducer`) |
| TypeScript | 显式 (`class Person implements Introducer`) |

---

## 九、总结

### 开发流程

```
1. 创建项目
   go mod init 模块名

2. 创建子目录（存放可复用代码）
   新建目录，编写.go文件，包名自定义，函数首字母大写

3. 配置replace（本地开发）
   go.mod中添加 replace 指令

4. 调用子包
   main.go中使用 import 导入，使用 别名.函数() 调用

5. 运行
   go run main.go
```

### 关键规则

| 场景 | 包名 | 函数可见性 | 调用方式 |
|-----|------|-----------|---------|
| 同一目录 | 相同 | 大小写都可 | 直接调用 |
| 不同目录 | 不同 | 仅大写 | import + 别名.函数() |

---

## 九、Go基础语法核心概念（Lessons 1-8）

### 9.1 第1课：Hello World

| 概念 | 说明 | 示例 |
|-----|------|------|
| package | 包声明，每个文件必须属于一个包 | `package mybase` |
| import | 导入标准库 | `import "fmt"` |
| fmt.Println | 打印并换行 | `fmt.Println("Hello")` |
| fmt.Printf | 格式化输出 | `fmt.Printf("Name: %s\n", name)` |

### 9.2 第2课：变量声明

| 声明方式 | 语法 | 示例 |
|---------|------|------|
| var 完整声明 | `var 变量名 类型 = 值` | `var name string = "Austoin"` |
| 简短声明 | `变量名 := 值` | `city := "重庆"` |
| 常量 | `const 变量名 = 值` | `const pi = 3.14` |

### 9.3 第3课：基本数据类型

| 类型 | 说明 | 示例 |
|-----|------|------|
| 整型 | int, int8/16/32/64, uint | `var age int = 22` |
| 无符号 | uint, uint8/16/32/64 | `var savings uint = 100000` |
| 浮点型 | float32, float64 | `var height float64 = 1.75` |
| 布尔型 | true, false | `var isStudent bool = true` |
| 字符串 | UTF-8文本 | `var name string = "Austoin"` |

**零值**：
- int/float → 0
- bool → false
- string → ""

### 9.4 第4课：条件语句

| 语句 | 说明 | 示例 |
|-----|------|------|
| if | 单条件判断 | `if score >= 90 { ... }` |
| if-else | 双条件判断 | `if ... { } else { }` |
| if-else if | 多条件判断 | `if ... { } else if ... { } else { }` |
| switch | 多值匹配 | `switch day { case 1: ... }` |
| switch 多case | 合并条件 | `case 3,4,5: ...` |

### 9.5 第5课：循环语句

| 循环类型 | 说明 | 示例 |
|---------|------|------|
| for | 基础循环 | `for i := 0; i < 5; i++ { }` |
| while效果 | 省略初始化和增量 | `for i < 5 { i++ }` |
| for range | 遍历切片/映射 | `for index, value := range nums { }` |
| break | 退出循环 | `if i == 5 { break }` |
| continue | 跳过本次 | `if i == 3 { continue }` |

### 9.6 第6课：函数

| 特性 | 说明 | 示例 |
|-----|------|------|
| 基本函数 | 有参数有返回值 | `func add(a, b int) int { return a+b }` |
| 多返回值 | 返回多个值 | `func divide(a,b float64) (float64, error)` |
| 变长参数 | 接收任意数量参数 | `func sum(nums ...int) int { }` |
| 递归 | 函数调用自身 | `func factorial(n int) int { if n<=1 { return 1 }; return n*factorial(n-1) }` |

### 9.7 第7课：复合类型

| 数据结构 | 特点 | 关键操作 |
|---------|------|---------|
| **数组** | 固定长度，值类型 | `var arr [5]int` |
| **切片** | 动态长度，引用类型 | `s := []int{1,2,3}` |
| **映射** | 键值对，无序 | `m := map[string]int{}` |

**切片操作**：
- `append()` - 追加元素
- `make()` - 创建切片
- `len()`, `cap()` - 长度和容量
- 子切片 `[start:end]`

**映射操作**：
- 添加/修改：`m["key"] = value`
- 获取：`value, exists := m["key"]`
- 删除：`delete(m, "key")`

### 9.8 第8课：结构体和方法

| 概念 | 说明 | 示例 |
|-----|------|------|
| 结构体 | 自定义数据类型 | `type Person struct { Name string; Age int }` |
| 声明初始化 | 三种方式 | `p := Person{Name: "Austoin", Age: 22}` |
| 嵌套结构体 | 结构体包含结构体 | `type Student struct { Person; Score float64 }` |
| 值接收者 | 操作副本 | `func (p Person) GrowUp() { p.Age++ }` |
| 指针接收者 | 操作原值 | `func (p *Person) GrowUp() { p.Age++ }` |

### 9.9 核心语法速查表

| 类别 | 语法 | 说明 |
|-----|------|------|
| 变量 | `var x int` / `x := 10` | 声明/简短声明 |
| 常量 | `const PI = 3.14` | 编译期确定 |
| 条件 | `if/else`, `switch` | 流程控制 |
| 循环 | `for`, `for range` | 迭代 |
| 函数 | `func name(params) return {}` | 代码复用 |
| 数组 | `[5]int{1,2,3}` | 固定长度 |
| 切片 | `[]int{1,2,3}` | 动态数组 |
| 映射 | `map[string]int{}` | 键值对 |
| 结构体 | `struct { Name string }` | 自定义类型 |
| 方法 | `func (receiver Type) Method() {}` | 关联类型 |

---

## 10、第9课并发编程（已学完）

### 10.1 Goroutine 协程

| 概念 | 说明 |
|-----|------|
| goroutine | Go语言实现的轻量级线程，由runtime管理 |
| 初始栈大小 | 约2KB（线程约1MB） |
| 创建方式 | `go 函数名()` 或 `go func(){}()` |

```go
// 1. 普通函数作为协程
go say("Hello")

// 2. 匿名协程
go func() {
    fmt.Println("匿名协程")
}()

// 注意：主程序退出时，所有协程会被强制终止
time.Sleep(100 * time.Millisecond)
```

### 10.2 Channel 通道

| 类型 | 说明 | 示例 |
|-----|------|-----|
| 无缓冲Channel | 发送和接收必须同时进行，否则阻塞 | `ch := make(chan int)` |
| 有缓冲Channel | 可以暂存数据，缓冲区满时才阻塞 | `ch := make(chan int, 3)` |
| 关闭Channel | `close(ch)`，接收方可用ok判断 | `v, ok := <-ch` |

```go
// 无缓冲Channel（发送接收必须同时）
ch1 := make(chan string)
go func() { ch1 <- "消息" }()
msg := <-ch1

// 有缓冲Channel（容量3）
ch2 := make(chan int, 3)
ch2 <- 1  // 不阻塞
ch2 <- 2  // 不阻塞
ch2 <- 3  // 不阻塞
// ch2 <- 4  // 阻塞！缓冲区已满

// 关闭 + range遍历
ch3 := make(chan int, 5)
go func() {
    for i := 1; i <= 5; i++ { ch3 <- i }
    close(ch3)
}()
for v := range ch3 {
    fmt.Println(v)
}
```

### 10.3 WaitGroup 等待组

| 方法 | 作用 |
|-----|------|
| `Add(n)` | 增加等待计数 |
| `Done()` | 减少计数（协程结束时调用） |
| `Wait()` | 阻塞等待，直到计数变为0 |

```go
var wg sync.WaitGroup

for i := 1; i <= 3; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()  // 确保执行
        fmt.Printf("Task %d\n", id)
    }(i)
}

wg.Wait()  // 等待所有协程完成
```

### 10.4 Mutex 互斥锁

| 方法 | 作用 |
|-----|------|
| `Lock()` | 加锁，其他协程阻塞等待 |
| `Unlock()` | 解锁 |

```go
var (
    counter int
    mutex   sync.Mutex
)

for i := 0; i < 1000; i++ {
    go func() {
        mutex.Lock()
        counter++
        mutex.Unlock()
    }()
}
time.Sleep(100 * time.Millisecond)
fmt.Println(counter)  // 1000
```

### 10.5 Select 选择器

| 特性 | 说明 |
|-----|------|
| 多通道监听 | 同时等待多个Channel |
| 超时控制 | `time.After(duration)` |
| default | 都不就绪时执行（非阻塞） |

```go
ch5 := make(chan int)
ch6 := make(chan int)

go func() { ch5 <- 100 }()
go func() { ch6 <- 200 }()

select {
case v1 := <-ch5: fmt.Println("ch5:", v1)
case v2 := <-ch6: fmt.Println("ch6:", v2)
}

// 超时控制
timeout := time.After(100 * time.Millisecond)
done := make(chan bool)

go func() {
    time.Sleep(200 * time.Millisecond)
    done <- true
}()

select {
case <-done:   fmt.Println("完成")
case <-timeout: fmt.Println("超时")
}
```

### 10.6 完整代码结构

```
Lesson9()
├── goroutineDemo()  // goroutine基础
├── channelDemo()    // channel收发
├── waitGroupDemo()  // waitgroup等待
├── mutexDemo()      // 互斥锁
└── selectDemo()     // select超时
```

### 10.7 用户代码亮点

- ✅ 正确使用WaitGroup等待协程
- ✅ 正确理解无缓冲/有缓冲Channel区别
- ✅ 正确使用range遍历Channel
- ✅ 正确使用Mutex保护共享变量
- ✅ 正确使用select实现超时控制
- ⚠️ 补充：defer在panic时也会执行

---

## 11、第10课错误处理（已学完）

### 11.1 error 接口

| 创建方式 | 说明 | 使用场景 |
|---------|------|---------|
| `errors.New()` | 创建简单错误 | 静态错误消息 |
| `fmt.Errorf()` | 创建格式化错误 | 动态拼接错误信息（%s） |

```go
err1 := errors.New("文件不存在")
err2 := fmt.Errorf("文件 %s 读取失败", filename)
```

### 11.2 函数返回错误

**Go惯用法：** 函数返回多个值时，最后一个是 error，nil 表示没有错误。

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("除数不能为零")
    }
    return a / b, nil
}

result, err := divide(10, 0)
if err != nil {
    fmt.Println("错误:", err)
}
```

### 11.3 自定义错误

```go
var ErrInvalidAge = errors.New("年龄无效")

func validateAge(age int) (bool, error) {
    if age < 0 || age > 150 {
        return false, ErrInvalidAge
    }
    return true, nil
}

// errors.Is() 判断错误类型
if _, err := validateAge(-1); errors.Is(err, ErrInvalidAge) {
    fmt.Println("年龄验证失败")
}
```

### 11.4 panic 恐慌

| 特性 | 说明 |
|-----|------|
| 终止执行 | 当前函数立即停止 |
| 传播方向 | 沿调用栈向上传播 |
| 崩溃条件 | 没有recover捕获时程序退出 |

```go
panic("消息")  // 手动触发
// 数组越界、空指针等运行时错误也会触发panic
```

### 11.5 recover 恢复

**只能在 defer 函数中使用。**

```go
defer func() {
    if r := recover(); r != nil {
        fmt.Printf("捕获到panic: %v\n", r)
    }
}()
```

### 11.6 defer 执行顺序

**栈结构：先定义的后执行。**

```go
defer fmt.Println("defer 1 (最后执行)")  // 第2个执行
defer fmt.Println("defer 2 (其次执行)")  // 第1个执行
```

### 11.7 错误处理策略

| 等级 | 类型 | 使用 | 示例 |
|-----|------|-----|------|
| L1 | 可预见错误 | 返回 error | 文件不存在、参数验证 |
| L2 | 真正异常 | panic | 配置错误、空指针 |
| L3 | 防止崩溃 | defer + recover | 捕获panic，记录日志 |

### 11.8 完整代码结构

```
Lesson10()
├── errorDemo()       // errors.New、fmt.Errorf
├── divide()          // 返回 error
├── validateAge()     // 自定义错误
├── panicDemo()       // panic触发
├── triggerPanic()   // panic传播
├── recoverDemo()    // recover捕获
├── safeFunction()   // defer+recover
├── completeDemo()   // defer顺序
├── nestedPanic()    // 嵌套panic
├── checkErrorType() // errors.Is
└── validateConfig() // 错误策略
```

### 11.9 用户代码亮点

- ✅ errors.New 和 fmt.Errorf 创建错误
- ✅ errors.Is 判断错误类型
- ✅ panic 传播机制
- ✅ defer + recover 捕获panic
- ✅ defer 执行顺序（后进先出）
- ✅ 区分 error 和 panic 使用场景
- ✅ _, ok 检查 map 键是否存在

- Go官方模块文档：https://golang.org/ref/mod
- Go模块命令：https://golang.org/cmd/go/#hdr-Module_maintenance
