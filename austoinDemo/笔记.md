# Go模块管理笔记

> 记录日期：2026-02-06
> 适用场景：本地开发、跨目录模块调用

---

## 一、核心概念

### 1.1 模块（Module）是什么？

**模块 = 项目 = 一个 `go.mod` 文件**

| 概念 | 说明 |
|-----|------|
| 模块 | Go依赖管理的基本单位 |
| go.mod | 模块声明文件，记录模块名、版本、依赖 |
| go.sum | 依赖校验文件，确保依赖1.2 包安全 |

### （Package）是什么？

**包 = 目录 = 一组 `.go` 文件**

| 规则 | 说明 |
|-----|------|
| 同一目录 | 同一包，直接调用 |
| 不同目录 | 不同包，需要导入 |
| 包名 | 目录名或自定义，通常与目录名一致 |

---

## 二、本地模块开发

### 2.1 问题背景

正常情况下，Go期望从**远程仓库**下载模块：
```
import "github.com/用户名/项目名/子目录"
```

但开发阶段代码在**本地**，没有上传GitHub。

### 2.2 解决方案：replace 指令

**作用**：告诉Go"这个模块虽然在远程路径里，但实际上在本地"

#### 配置步骤

**步骤1：根目录执行初始化（只需一次）**
```bash
cd GolangTutorial
go mod init github.com/austoin/golangtutorial
```

**步骤2：在go.mod中添加replace指令**
```go
module github.com/austoin/golangtutorial

go 1.25.6

replace 远程路径 => 本地路径
```

**步骤3：编写调用代码**
```go
package main

import (
    别名 "远程路径"
)

func main() {
    别名.公开函数()
}
```

---

## 三、实战：austoinDemo/A-base 调用示例

### 3.1 目录结构

```
GolangTutorial/
├── go.mod                    ← 根模块
│
├── austoinDemo/
│   ├── main.go               ← 主程序（调用方）
│   └── A-base/               ← 子包（被调用方）
│       ├── 1.go
│       ├── 2.go
│       └── ...
```

### 3.2 被调用方：A-base/*.go

```go
// A-base/1.go
package lesson  // 包名

func Lesson1() {  // 首字母大写 = 公开，可被其他包访问
    fmt.Println("Hello, World!")
}
```

**关键点**：
- 包名：`lesson`（与目录名无关，可自定义）
- 函数名：`Lesson1()` 首字母大写（公开）
- 同目录下其他文件也需要 `package lesson`

### 3.3 调用方：main.go

```go
// austoinDemo/main.go
package main

import (
    abaselib "github.com/austoin/golangtutorial/austoinDemo/A-base"
)

func main() {
    abaselib.Lesson1()
}
```

**关键点**：
- 导入路径 = 模块路径 + 子目录路径
- 使用别名避免冲突：`abaselib` 是别名
- 调用方式：`别名.公开函数()`

### 3.4 根目录：go.mod

```go
module github.com/austoin/golangtutorial

go 1.25.6

replace github.com/austoin/golangtutorial/austoinDemo/A-base => ./austoinDemo/A-base
```

**关键点**：
- `replace` 指令将远程路径映射到本地路径
- `=>` 左边是远程路径，右边是本地路径

---

## 四、远程模块调用

### 4.1 调用第三方库

```go
package main

import (
    "github.com/gin-gonic/gin"  // Web框架
    "gorm.io/gorm"              // ORM库
    "github.com/redis/go-redis/v9"  // Redis客户端
)

func main() {
    // 使用第三方库
    r := gin.Default()
    r.GET("/", func(c *gin.Context) {
        c.String(200, "Hello!")
    })
    r.Run()
}
```

### 4.2 下载依赖

```bash
go mod tidy
```

**作用**：
1. 扫描代码中的 `import`，识别使用的依赖
2. 下载依赖到本地
3. 自动更新 `go.mod` 和 `go.sum`

---

## 五、go.mod 详解

### 5.1 最小配置

```go
module 模块名

go 版本号
```

### 5.2 完整配置

```go
module github.com/用户名/项目名

go 1.25.6

require (
    第三方库1 v1.0.0
    第三方库2 v2.0.0
)

replace 本地路径 => 远程路径

replace 本地路径 => ./本地子目录
```

### 5.3 常用命令

| 命令 | 作用 |
|-----|------|
| `go mod init 模块名` | 初始化模块（创建go.mod） |
| `go mod tidy` | 下载依赖，更新go.mod/go.sum |
| `go mod download` | 下载所有依赖 |
| `go get 包名@版本` | 下载指定包 |
| `go env -w GOPROXY=...` | 设置代理（国内用goproxy.cn） |

---

## 六、常见问题

### Q1: 相对路径导入报错？

**错误**：
```
local import "./A-base" in non-local package
```

**原因**：Go 1.16+ 不支持相对路径导入

**解决**：使用模块路径 + replace 指令

### Q2: ambiguous import？

**错误**：
```
found package in multiple modules
```

**原因**：
- 模块在主模块和子模块中都存在
- 重复的 require 声明

**解决**：
1. 删除子目录的独立 go.mod
2. 清理根目录 go.mod 中多余的 require

### Q3: 找不到包？

**错误**：
```
cannot find package
```

**原因**：
- 没有运行 `go mod tidy`
- replace 路径错误

**解决**：
```bash
go mod tidy
# 检查 replace 路径是否正确
```

---

## 七、可见性规则

### 7.1 函数/变量可见性

```go
package lesson

func PublicFunc() {}    // ✅ 首字母大写 = 公开，其他包可访问

func privateFunc() {}   // ❌ 首字母小写 = 私有，其他包不可访问
```

### 7.2 结构体可见性

```go
package lesson

type PublicStruct struct {  // ✅ 公开
    Name string  // 字段也可以控制可见性
}

type privateStruct struct {  // ❌ 私有
    age int
}
```

---

## 八、接口与隐式实现

### 8.1 什么是接口？

**接口 = 方法签名的集合**，定义对象应该具备什么行为。

```go
// 定义接口
type Introducer interface {
    Introduce() string  // 要求实现这个方法
}
```

### 8.2 隐式实现（Go的特性）

**在Go中，接口是隐式实现的**——不需要显式声明"我实现了这个接口"。

只要结构体拥有接口中定义的所有方法，它就**自动**实现了该接口。

```go
// 1. 定义接口
type Introducer interface {
    Introduce() string
}

// 2. 定义结构体
type Person struct {
    Name string
    Age  int
}

// 3. 结构体拥有接口要求的方法
func (p Person) Introduce() string {
    return fmt.Sprintf("我叫%s，今年%d岁", p.Name, p.Age)
}

// 4. 因此 Person 自动实现了 Introducer 接口
//    不需要像 Java 那样写：class Person implements Introducer
```

### 8.3 原理：鸭子类型

> "如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子"

```
Person 有 Introduce() 方法
        ↓
自动满足 Introducer 接口
        ↓
Person 的对象可以当作 Introducer 使用
```

### 8.4 接口的实际应用

```go
// 接口可以存储任何实现了该接口的类型
var greeter Introducer

p1 := Person{Name: "Eve", Age: 32}
greeter = p1  // ✅ 可以，因为 Person 实现了 Introducer

fmt.Printf("%s\n", greeter.Introduce())

// 遍历实现接口的对象
people := []Person{
    {Name: "Charlie", Age: 35},
    {Name: "Diana", Age: 28},
}

for _, p := range people {
    fmt.Printf("%s 说: %s\n", p.Name, p.Introduce())
}
```

### 8.5 空接口 interface{}

空接口可以存储**任意类型**：

```go
var anything interface{}

anything = 42
fmt.Printf("anything: %v\n", anything)  // 42

anything = "hello"
fmt.Printf("anything: %v\n", anything)  // hello

anything = []int{1, 2, 3}
fmt.Printf("anything: %v\n", anything)  // [1 2 3]
```

### 8.6 对比：显式 vs 隐式实现

| 语言 | 实现方式 |
|-----|---------|
| **Go** | 隐式（自动） |
| Java | 显式 (`class Person implements Introducer`) |
| TypeScript | 显式 (`class Person implements Introducer`) |

---

## 九、总结

### 开发流程

```
1. 创建项目
   go mod init 模块名

2. 创建子目录（存放可复用代码）
   新建目录，编写.go文件，包名自定义，函数首字母大写

3. 配置replace（本地开发）
   go.mod中添加 replace 指令

4. 调用子包
   main.go中使用 import 导入，使用 别名.函数() 调用

5. 运行
   go run main.go
```

### 关键规则

| 场景 | 包名 | 函数可见性 | 调用方式 |
|-----|------|-----------|---------|
| 同一目录 | 相同 | 大小写都可 | 直接调用 |
| 不同目录 | 不同 | 仅大写 | import + 别名.函数() |

---

## 九、Go基础语法核心概念（Lessons 1-8）

### 9.1 第1课：Hello World

| 概念 | 说明 | 示例 |
|-----|------|------|
| package | 包声明，每个文件必须属于一个包 | `package mybase` |
| import | 导入标准库 | `import "fmt"` |
| fmt.Println | 打印并换行 | `fmt.Println("Hello")` |
| fmt.Printf | 格式化输出 | `fmt.Printf("Name: %s\n", name)` |

### 9.2 第2课：变量声明

| 声明方式 | 语法 | 示例 |
|---------|------|------|
| var 完整声明 | `var 变量名 类型 = 值` | `var name string = "Austoin"` |
| 简短声明 | `变量名 := 值` | `city := "重庆"` |
| 常量 | `const 变量名 = 值` | `const pi = 3.14` |

### 9.3 第3课：基本数据类型

| 类型 | 说明 | 示例 |
|-----|------|------|
| 整型 | int, int8/16/32/64, uint | `var age int = 22` |
| 无符号 | uint, uint8/16/32/64 | `var savings uint = 100000` |
| 浮点型 | float32, float64 | `var height float64 = 1.75` |
| 布尔型 | true, false | `var isStudent bool = true` |
| 字符串 | UTF-8文本 | `var name string = "Austoin"` |

**零值**：
- int/float → 0
- bool → false
- string → ""

### 9.4 第4课：条件语句

| 语句 | 说明 | 示例 |
|-----|------|------|
| if | 单条件判断 | `if score >= 90 { ... }` |
| if-else | 双条件判断 | `if ... { } else { }` |
| if-else if | 多条件判断 | `if ... { } else if ... { } else { }` |
| switch | 多值匹配 | `switch day { case 1: ... }` |
| switch 多case | 合并条件 | `case 3,4,5: ...` |

### 9.5 第5课：循环语句

| 循环类型 | 说明 | 示例 |
|---------|------|------|
| for | 基础循环 | `for i := 0; i < 5; i++ { }` |
| while效果 | 省略初始化和增量 | `for i < 5 { i++ }` |
| for range | 遍历切片/映射 | `for index, value := range nums { }` |
| break | 退出循环 | `if i == 5 { break }` |
| continue | 跳过本次 | `if i == 3 { continue }` |

### 9.6 第6课：函数

| 特性 | 说明 | 示例 |
|-----|------|------|
| 基本函数 | 有参数有返回值 | `func add(a, b int) int { return a+b }` |
| 多返回值 | 返回多个值 | `func divide(a,b float64) (float64, error)` |
| 变长参数 | 接收任意数量参数 | `func sum(nums ...int) int { }` |
| 递归 | 函数调用自身 | `func factorial(n int) int { if n<=1 { return 1 }; return n*factorial(n-1) }` |

### 9.7 第7课：复合类型

| 数据结构 | 特点 | 关键操作 |
|---------|------|---------|
| **数组** | 固定长度，值类型 | `var arr [5]int` |
| **切片** | 动态长度，引用类型 | `s := []int{1,2,3}` |
| **映射** | 键值对，无序 | `m := map[string]int{}` |

**切片操作**：
- `append()` - 追加元素
- `make()` - 创建切片
- `len()`, `cap()` - 长度和容量
- 子切片 `[start:end]`

**映射操作**：
- 添加/修改：`m["key"] = value`
- 获取：`value, exists := m["key"]`
- 删除：`delete(m, "key")`

### 9.8 第8课：结构体和方法

| 概念 | 说明 | 示例 |
|-----|------|------|
| 结构体 | 自定义数据类型 | `type Person struct { Name string; Age int }` |
| 声明初始化 | 三种方式 | `p := Person{Name: "Austoin", Age: 22}` |
| 嵌套结构体 | 结构体包含结构体 | `type Student struct { Person; Score float64 }` |
| 值接收者 | 操作副本 | `func (p Person) GrowUp() { p.Age++ }` |
| 指针接收者 | 操作原值 | `func (p *Person) GrowUp() { p.Age++ }` |

### 9.9 核心语法速查表

| 类别 | 语法 | 说明 |
|-----|------|------|
| 变量 | `var x int` / `x := 10` | 声明/简短声明 |
| 常量 | `const PI = 3.14` | 编译期确定 |
| 条件 | `if/else`, `switch` | 流程控制 |
| 循环 | `for`, `for range` | 迭代 |
| 函数 | `func name(params) return {}` | 代码复用 |
| 数组 | `[5]int{1,2,3}` | 固定长度 |
| 切片 | `[]int{1,2,3}` | 动态数组 |
| 映射 | `map[string]int{}` | 键值对 |
| 结构体 | `struct { Name string }` | 自定义类型 |
| 方法 | `func (receiver Type) Method() {}` | 关联类型 |

---

## 10、第9课并发编程（已学完）

### 10.1 Goroutine 协程

| 概念 | 说明 |
|-----|------|
| goroutine | Go语言实现的轻量级线程，由runtime管理 |
| 初始栈大小 | 约2KB（线程约1MB） |
| 创建方式 | `go 函数名()` 或 `go func(){}()` |

```go
// 1. 普通函数作为协程
go say("Hello")

// 2. 匿名协程
go func() {
    fmt.Println("匿名协程")
}()

// 注意：主程序退出时，所有协程会被强制终止
time.Sleep(100 * time.Millisecond)
```

### 10.2 Channel 通道

| 类型 | 说明 | 示例 |
|-----|------|-----|
| 无缓冲Channel | 发送和接收必须同时进行，否则阻塞 | `ch := make(chan int)` |
| 有缓冲Channel | 可以暂存数据，缓冲区满时才阻塞 | `ch := make(chan int, 3)` |
| 关闭Channel | `close(ch)`，接收方可用ok判断 | `v, ok := <-ch` |

```go
// 无缓冲Channel（发送接收必须同时）
ch1 := make(chan string)
go func() { ch1 <- "消息" }()
msg := <-ch1

// 有缓冲Channel（容量3）
ch2 := make(chan int, 3)
ch2 <- 1  // 不阻塞
ch2 <- 2  // 不阻塞
ch2 <- 3  // 不阻塞
// ch2 <- 4  // 阻塞！缓冲区已满

// 关闭 + range遍历
ch3 := make(chan int, 5)
go func() {
    for i := 1; i <= 5; i++ { ch3 <- i }
    close(ch3)
}()
for v := range ch3 {
    fmt.Println(v)
}
```

### 10.3 WaitGroup 等待组

| 方法 | 作用 |
|-----|------|
| `Add(n)` | 增加等待计数 |
| `Done()` | 减少计数（协程结束时调用） |
| `Wait()` | 阻塞等待，直到计数变为0 |

```go
var wg sync.WaitGroup

for i := 1; i <= 3; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()  // 确保执行
        fmt.Printf("Task %d\n", id)
    }(i)
}

wg.Wait()  // 等待所有协程完成
```

### 10.4 Mutex 互斥锁

| 方法 | 作用 |
|-----|------|
| `Lock()` | 加锁，其他协程阻塞等待 |
| `Unlock()` | 解锁 |

```go
var (
    counter int
    mutex   sync.Mutex
)

for i := 0; i < 1000; i++ {
    go func() {
        mutex.Lock()
        counter++
        mutex.Unlock()
    }()
}
time.Sleep(100 * time.Millisecond)
fmt.Println(counter)  // 1000
```

### 10.5 Select 选择器

| 特性 | 说明 |
|-----|------|
| 多通道监听 | 同时等待多个Channel |
| 超时控制 | `time.After(duration)` |
| default | 都不就绪时执行（非阻塞） |

```go
ch5 := make(chan int)
ch6 := make(chan int)

go func() { ch5 <- 100 }()
go func() { ch6 <- 200 }()

select {
case v1 := <-ch5: fmt.Println("ch5:", v1)
case v2 := <-ch6: fmt.Println("ch6:", v2)
}

// 超时控制
timeout := time.After(100 * time.Millisecond)
done := make(chan bool)

go func() {
    time.Sleep(200 * time.Millisecond)
    done <- true
}()

select {
case <-done:   fmt.Println("完成")
case <-timeout: fmt.Println("超时")
}
```

### 10.6 完整代码结构

```
Lesson9()
├── goroutineDemo()  // goroutine基础
├── channelDemo()    // channel收发
├── waitGroupDemo()  // waitgroup等待
├── mutexDemo()      // 互斥锁
└── selectDemo()     // select超时
```

### 10.7 用户代码亮点

- ✅ 正确使用WaitGroup等待协程
- ✅ 正确理解无缓冲/有缓冲Channel区别
- ✅ 正确使用range遍历Channel
- ✅ 正确使用Mutex保护共享变量
- ✅ 正确使用select实现超时控制
- ⚠️ 补充：defer在panic时也会执行

---

## 11、第10课错误处理（已学完）

### 11.1 error 接口

| 创建方式 | 说明 | 使用场景 |
|---------|------|---------|
| `errors.New()` | 创建简单错误 | 静态错误消息 |
| `fmt.Errorf()` | 创建格式化错误 | 动态拼接错误信息（%s） |

```go
err1 := errors.New("文件不存在")
err2 := fmt.Errorf("文件 %s 读取失败", filename)
```

### 11.2 函数返回错误

**Go惯用法：** 函数返回多个值时，最后一个是 error，nil 表示没有错误。

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("除数不能为零")
    }
    return a / b, nil
}

result, err := divide(10, 0)
if err != nil {
    fmt.Println("错误:", err)
}
```

### 11.3 自定义错误

```go
var ErrInvalidAge = errors.New("年龄无效")

func validateAge(age int) (bool, error) {
    if age < 0 || age > 150 {
        return false, ErrInvalidAge
    }
    return true, nil
}

// errors.Is() 判断错误类型
if _, err := validateAge(-1); errors.Is(err, ErrInvalidAge) {
    fmt.Println("年龄验证失败")
}
```

### 11.4 panic 恐慌

| 特性 | 说明 |
|-----|------|
| 终止执行 | 当前函数立即停止 |
| 传播方向 | 沿调用栈向上传播 |
| 崩溃条件 | 没有recover捕获时程序退出 |

```go
panic("消息")  // 手动触发
// 数组越界、空指针等运行时错误也会触发panic
```

### 11.5 recover 恢复

**只能在 defer 函数中使用。**

```go
defer func() {
    if r := recover(); r != nil {
        fmt.Printf("捕获到panic: %v\n", r)
    }
}()
```

### 11.6 defer 执行顺序

**栈结构：先定义的后执行。**

```go
defer fmt.Println("defer 1 (最后执行)")  // 第2个执行
defer fmt.Println("defer 2 (其次执行)")  // 第1个执行
```

### 11.7 错误处理策略

| 等级 | 类型 | 使用 | 示例 |
|-----|------|-----|------|
| L1 | 可预见错误 | 返回 error | 文件不存在、参数验证 |
| L2 | 真正异常 | panic | 配置错误、空指针 |
| L3 | 防止崩溃 | defer + recover | 捕获panic，记录日志 |

### 11.8 完整代码结构

```
Lesson10()
├── errorDemo()       // errors.New、fmt.Errorf
├── divide()          // 返回 error
├── validateAge()     // 自定义错误
├── panicDemo()       // panic触发
├── triggerPanic()   // panic传播
├── recoverDemo()    // recover捕获
├── safeFunction()   // defer+recover
├── completeDemo()   // defer顺序
├── nestedPanic()    // 嵌套panic
├── checkErrorType() // errors.Is
└── validateConfig() // 错误策略
```

### 11.9 用户代码亮点

- ✅ errors.New 和 fmt.Errorf 创建错误
- ✅ errors.Is 判断错误类型
- ✅ panic 传播机制
- ✅ defer + recover 捕获panic
- ✅ defer 执行顺序（后进先出）
- ✅ 区分 error 和 panic 使用场景
- ✅ _, ok 检查 map 键是否存在

---

## 12、第11课包和模块（已学完）

### 12.1 Module 模块

**是什么：** Go依赖管理的基本单位 = 一个项目 = 一个 `go.mod` 文件。

```go
module github.com/austoin/golangtutorial

go 1.25.6

require (
    gin-gonic/gin v1.9.1
)

replace 本地路径 => 远程路径
```

| 指令 | 作用 |
|-----|------|
| `module` | 声明模块路径（唯一标识） |
| `go` | 声明Go版本 |
| `require` | 声明依赖的外部模块 |
| `replace` | 替换模块路径（本地开发用） |

### 12.2 Package 包

**是什么：** 包 = 目录 = 一组 `.go` 文件。

```go
// 练习文件：austoinDemo/A-base/11.go
package mybase  // 包名自定义，不一定要与目录名一致

import (
    "fmt"
    "time"
)
```

| 规则 | 说明 |
|-----|------|
| 同一目录 | 同一包，直接调用 |
| 不同目录 | 不同包，需要导入 |
| 包名 | 可以自定义（你的练习用 `mybase`） |

### 12.3 可见性规则

```go
func PublicFunc() {}    // ✅ 首字母大写 = 公开，其他包可访问

func privateFunc() {}   // ❌ 首字母小写 = 私有，其他包不可访问
```

### 12.4 导入方式

```go
import (
    "fmt"     // 标准库
    "time"    // 标准库
    别名 "路径"  // 带别名导入
)
```

### 12.5 replace 指令

**作用：** 本地开发时，将远程路径映射到本地路径。

```go
// go.mod
replace github.com/austoin/golangtutorial/austoinDemo/A-base => ./austoinDemo/A-base
```

### 12.6 常用命令

| 命令 | 作用 |
|-----|------|
| `go mod init 模块名` | 初始化模块 |
| `go mod tidy` | 下载依赖，更新文件 |
| `go mod download` | 下载所有依赖 |
| `go get 包名@版本` | 下载指定包 |

### 12.7 完整代码结构

```
Lesson11()
├── packageDemo()   // 包和可见性
├── importDemo()   // 导入方式
└── moduleDemo()   // 本地模块开发
```

### 12.8 用户代码亮点

- ✅ 正确理解包和模块的区别
- ✅ 正确使用可见性规则（首字母大小写）
- ✅ 正确使用 time.Now() 获取时间
- ✅ 正确使用 fmt.Printf 格式化输出
- ✅ 正确注释 replace 指令的作用

---

## 13、第12课Gin框架（已学完）

### 13.1 Gin框架简介

**是什么：** Gin是Go语言中最流行的Web框架，基于httprouter开发，以高性能著称。

**核心组件：**

| 组件 | 说明 |
|-----|------|
| `gin.Engine` | 路由引擎，整个框架的核心 |
| `gin.Context` | 请求上下文，封装了请求和响应 |
| `gin.HandlerFunc` | 处理函数类型 |
| `gin.H` | map[string]interface{}的简写 |

**性能对比：**
- Gin：每秒处理约8500次请求
- Echo：每秒约7500次
- 标准库：http每秒约3500次

**安装：**
```bash
go get -u github.com/gin-gonic/gin
go mod tidy
```

**版本查看：**
```bash
go list -m github.com/gin-gonic/gin
```

---

### 13.2 创建路由器

```go
// ========== gin.Default() ==========
// 包含两个默认中间件：
// 1. Logger() - 记录请求日志
// 2. Recovery() - 从panic中恢复，防止服务器崩溃
router := gin.Default()

// ========== gin.New() ==========
// 不包含任何中间件，纯净版
// 需要自己添加中间件
router := gin.New()

// ========== 自定义中间件 ==========
router := gin.New()
router.Use(Logger())     // 添加日志中间件
router.Use(Recovery())   // 添加恢复中间件
router.Use(Cors())       // 添加跨域中间件
```

**gin.Engine结构：**

```go
type Engine struct {
    RouterGroup      // 路由组，包含所有路由规则
    maxParams        // 最大参数数量
    maxSections      // 最大分段数量
    HtmlRender      // HTML渲染器
    FuncMap         // 模板函数映射
    contextPool     // Context对象池
    pool            // sync.Pool
    tree            // 路由树
    UsingXMLOutput  // 是否使用XML输出
    WithJSONPayloadAsContentType // JSON负载作为Content-Type
}
```

**路由器配置：**

```go
// 设置运行模式
gin.SetMode(gin.DebugMode)   // 开发模式
gin.SetMode(gin.ReleaseMode) // 生产模式
gin.SetMode(gin.TestMode)   // 测试模式

// 设置路由前缀
router := gin.New()
router.Use(gin.LoggerWithConfig(gin.LoggerConfig{
    Output: os.Stdout,  // 日志输出位置
    SkipPaths: []string{"/health"}, // 跳过某些路径
}))
```

---

### 13.3 HTTP方法与路由

**支持的HTTP方法：**

| 方法 | 语义 | 幂等 | 使用场景 |
|-----|------|-----|---------|
| GET | 查询资源 | 是 | 获取数据 |
| POST | 创建资源 | 否 | 提交数据 |
| PUT | 完整更新 | 是 | 更新整个资源 |
| PATCH | 部分更新 | 否 | 更新部分字段 |
| DELETE | 删除资源 | 是 | 删除数据 |
| OPTIONS | 预检请求 | 是 | 检查支持的方法 |
| HEAD | 头部查询 | 是 | 只获取头部 |

**路由注册：**

```go
// 基础路由
router.GET("/users", func(c *gin.Context) {
    // 处理GET请求
    c.JSON(200, gin.H{"message": "用户列表"})
})

router.POST("/users", func(c *gin.Context) {
    // 处理POST请求
    c.JSON(201, gin.H{"message": "创建用户"})
})

router.PUT("/users/:id", func(c *gin.Context) {
    // 处理PUT请求
    id := c.Param("id")
    c.JSON(200, gin.H{"message": "更新用户" + id})
})

router.DELETE("/users/:id", func(c *gin.Context) {
    // 处理DELETE请求
    id := c.Param("id")
    c.JSON(200, gin.H{"message": "删除用户" + id})
})

// 路由注册源码
func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes {
    return group.handle("GET", relativePath, handlers)
}
```

---

### 13.4 路径参数

**路径参数语法：**

| 语法 | 名称 | 说明 | 示例 |
|-----|------|------|------|
| `:name` | 命名参数 | 匹配单个路径段 | `/users/:id` |
| `*name` | 通配符 | 匹配剩余所有路径 | `/files/*filepath` |

**命名参数示例：**

```go
// 单个参数
router.GET("/users/:id", func(c *gin.Context) {
    // 获取参数
    id := c.Param("id")
    
    // 参数值类型是string
    // 访问 /users/123 -> id = "123"
    // 访问 /users/abc -> id = "abc"
    
    c.JSON(200, gin.H{"user_id": id})
})

// 多个参数
router.GET("/posts/:postId/comments/:commentId", func(c *gin.Context) {
    postId := c.Param("postId")
    commentId := c.Param("commentId")
    
    // 访问 /posts/1/comments/2
    // postId = "1", commentId = "2"
    
    c.JSON(200, gin.H{
        "post_id":    postId,
        "comment_id": commentId,
    })
})

// 可选参数 - 使用两个路由
router.GET("/users/:id", getUser)
router.GET("/users", listUsers)  // /users 和 /users/:id 都能匹配
```

**通配符示例：**

```go
router.GET("/files/*filepath", func(c *gin.Context) {
    filepath := c.Param("filepath")
    
    // 访问 /files/documents/report.pdf
    // filepath = "/documents/report.pdf"
    
    // 访问 /files/
    // filepath = "/"
    
    // 访问 /files
    // filepath = ""
    
    c.JSON(200, gin.H{"path": filepath})
})

// 嵌套通配符
router.GET("/api/*path", func(c *gin.Context) {
    path := c.Param("path")
    
    // 访问 /api/v1/users
    // path = "/v1/users"
    
    c.JSON(200, gin.H{"api_path": path})
})
```

**路径参数的限制：**

```go
// 1. 参数不能跨越 /
router.GET("/users/:name/profile", ...)  // :name 只能匹配 "zhangsan"，不能匹配 "zhangsan/profile"

// 2. 同一个路径段只能有一个参数
router.GET("/users/:id/:name", ...)  // 正确
router.GET("/users-:id-:name", ...) // 正确，可以混合使用

// 3. 通配符必须在最后
router.GET("/files/*filepath/images/*name", ...)  // 错误
```

---

### 13.5 查询参数

**获取查询参数：**

```go
router.GET("/search", func(c *gin.Context) {
    // ========== c.Query() ==========
    // 获取查询参数，不存在返回空字符串 ""
    q := c.Query("q")
    // URL: /search?q=Gin
    // q = "Gin"
    
    // ========== c.DefaultQuery() ==========
    // 获取参数，不存在返回默认值
    page := c.DefaultQuery("page", "1")
    size := c.DefaultQuery("size", "10")
    // URL: /search?page=2
    // page = "2", size = "10"
    
    // ========== c.GetQuery() ==========
    // 返回两个值：(value, exists)
    keyword, exists := c.GetQuery("keyword")
    if !exists {
        keyword = "默认值"
    }
    
    // ========== c.QueryMap() ==========
    // 获取查询参数 Map
    // URL: /search?filter[name]=zhangsan&filter[age]=25
    filter := c.QueryMap("filter")
    // filter = map[string]string{"name": "zhangsan", "age": "25"}
    
    c.JSON(200, gin.H{
        "q":      q,
        "page":   page,
        "size":   size,
        "filter": filter,
    })
})

// 表单参数（POST）
router.POST("/form", func(c *gin.Context) {
    // ========== c.PostForm() ==========
    // 获取表单参数
    username := c.PostForm("username")
    password := c.DefaultPostForm("password", "123456")
    
    // ========== c.GetPostForm() ==========
    // 返回(value, exists)
    email, exists := c.GetPostForm("email")
    
    c.JSON(200, gin.H{
        "username": username,
        "password": password,
        "email":    email,
    })
})
```

**查询参数注意事项：**

```go
// 1. 特殊字符会自动URL解码
// URL: /search?q=hello%20world
// c.Query("q") = "hello world"

// 2. 多个同名参数
// URL: /search?tag=Go&tag=Gin
// c.QueryArray("tag") = ["Go", "Gin"]
tags := c.QueryArray("tag")

// 3. 复杂查询
// URL: /search?q=Gin&page=1&size=20&sort=desc&fields=name,email
query := c.Request.URL.Query()
```

---

### 13.6 Header参数

**获取请求头：**

```go
router.GET("/header", func(c *gin.Context) {
    // ========== c.GetHeader() ==========
    // 获取请求头，不存在返回空字符串
    auth := c.GetHeader("Authorization")
    contentType := c.GetHeader("Content-Type")
    accept := c.GetHeader("Accept")
    userAgent := c.GetHeader("User-Agent")
    
    // ========== 常用Header ==========
    // Authorization: Bearer tokenxxx
    // Content-Type: application/json
    // Accept: application/json
    // User-Agent: Mozilla/5.0
    // X-Request-Id: xxx
    
    // 设置响应头
    c.Writer.Header().Set("X-Custom-Header", "value")
    c.Writer.Header().Set("Content-Type", "application/json")
    
    c.JSON(200, gin.H{
        "Authorization": auth,
        "Content-Type":  contentType,
        "Accept":        accept,
        "User-Agent":   userAgent,
    })
})
```

---

### 13.7 JSON绑定与验证

**结构体绑定：**

```go
// ========== 定义结构体 ==========
type User struct {
    ID       uint   `json:"id" binding:"required"`
    Username string `json:"username" binding:"required,min=3,max=20"`
    Email    string `json:"email" binding:"required,email"`
    Age      int    `json:"age" binding:"gte=0,lte=150"`
    Phone    string `json:"phone" binding:"omitempty"`
    Website  string `json:"website" binding:"url"`
}

// ========== 绑定JSON ==========
router.POST("/users", func(c *gin.Context) {
    var user User
    
    // ShouldBindJSON - 不自动返回400错误
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(400, gin.H{
            "error":   err.Error(),
            "message": "参数验证失败",
        })
        return
    }
    
    // BindJSON - 自动返回400错误
    // c.BindJSON(&user)
    
    c.JSON(201, gin.H{
        "message": "用户创建成功",
        "data":    user,
    })
})

// ========== 绑定查询参数 ==========
router.GET("/users", func(c *gin.Context) {
    type Query struct {
        Page     int    `form:"page" binding:"gte=1"`
        Size     int    `form:"size" binding:"gte=1,lte=100"`
        Username string `form:"username"`
    }
    
    var query Query
    if err := c.ShouldBindQuery(&query); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(200, gin.H{
        "page":     query.Page,
        "size":     query.Size,
        "username": query.Username,
    })
})

// ========== 绑定URI参数 ==========
router.GET("/users/:id", func(c *gin.Context) {
    type URI struct {
        ID uint `uri:"id" binding:"required,gt=0"`
    }
    
    var uri URI
    if err := c.ShouldBindUri(&uri); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(200, gin.H{"id": uri.ID})
})
```

**常用binding标签详解：**

| 标签 | 说明 | 示例 | 适用类型 |
|-----|------|------|---------|
| `required` | 必填 | `binding:"required"` | 任意 |
| `omitempty` | 为空时跳过验证 | `binding:"omitempty"` | 任意 |
| `min` | 最小值/最小长度 | `binding:"min=3"` | 数值/字符串 |
| `max` | 最大值/最大长度 | `binding:"max=100"` | 数值/字符串 |
| `len` | 固定长度 | `binding:"len=11"` | 数值/字符串 |
| `eq` | 等于 | `binding:"eq=100"` | 任意 |
| `ne` | 不等于 | `binding:"ne=0"` | 任意 |
| `gt` | 大于 | `binding:"gt=18"` | 数值 |
| `gte` | 大于等于 | `binding:"gte=18"` | 数值 |
| `lt` | 小于 | `binding:"lt=100"` | 数值 |
| `lte` | 小于等于 | `binding:"lte=100"` | 数值 |
| `email` | 邮箱格式 | `binding:"email"` | 字符串 |
| `url` | URL格式 | `binding:"url"` | 字符串 |
| `uri` | URI格式 | `binding:"uri"` | 字符串 |
| `hostname` | 主机名格式 | `binding:"hostname"` | 字符串 |
| `ip` | IP格式 | `binding:"ip"` | 字符串 |
| `ipv4` | IPv4格式 | `binding:"ipv4"` | 字符串 |
| `ipv6` | IPv6格式 | `binding:"ipv6"` | 字符串 |
| `cidr` | CIDR格式 | `binding:"cidr"` | 字符串 |
| `cidr4` | CIDRv4格式 | `binding:"cidr4"` | 字符串 |
| `cidr6` | CIDRv6格式 | `binding:"cidr6"` | 字符串 |
| `mac` | MAC地址格式 | `binding:"mac"` | 字符串 |
| `tcp4` | IPv4 TCP地址 | `binding:"tcp4"` | 字符串 |
| `tcp6` | IPv6 TCP地址 | `binding:"tcp6"` | 字符串 |
| `unix` | Unix地址 | `binding:"unix"` | 字符串 |
| `uuid` | UUID格式 | `binding:"uuid"` | 字符串 |
| `file` | 文件路径 | `binding:"file"` | 字符串 |
| `base64` | Base64编码 | `binding:"base64"` | 字符串 |
| `base64url` | Base64URL编码 | `binding:"base64url"` | 字符串 |
| `hexadecimal` | 十六进制 | `binding:"hexadecimal"` | 字符串 |
| `hexcolor` | 十六进制颜色 | `binding:"hexcolor"` | 字符串 |
| `rgb` | RGB颜色 | `binding:"rgb"` | 字符串 |
| `rgba` | RGBA颜色 | `binding:"rgba"` | 字符串 |
| `hsla` | HSLA颜色 | `binding:"hsla"` | 字符串 |
| `hsva` | HSVA颜色 | `binding:"hsva"` | 字符串 |
| `alphanum` | 只含字母数字 | `binding:"alphanum"` | 字符串 |
| `alpha` | 只含字母 | `binding:"alpha"` | 字符串 |
| `numeric` | 只含数字 | `binding:"numeric"` | 字符串 |
| `startswith` | 以某值开头 | `binding:"startswith=hello"` | 字符串 |
| `endswith` | 以某值结尾 | `binding:"endswith=world"` | 字符串 |

**组合验证：**

```go
type RegisterRequest struct {
    Username string `json:"username" binding:"required,min=3,max=20,alphanum"`
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=6,max=20"`
    Age      int    `json:"age" binding:"gte=18"`
    Phone    string `json:"phone" binding:"omitempty,len=11"`
}
```

---

### 13.8 响应

**JSON响应：**

```go
router.GET("/json", func(c *gin.Context) {
    // ========== gin.H 方式 ==========
    // gin.H 是 map[string]interface{} 的简写
    c.JSON(200, gin.H{
        "code":    0,
        "message": "success",
        "data": gin.H{
            "name": "austoin",
            "age":  25,
        },
    })
    
    // ========== 结构体方式 ==========
    type User struct {
        ID       uint   `json:"id"`
        Username string `json:"username"`
        Email    string `json:"email"`
    }
    
    user := User{ID: 1, Username: "austoin", Email: "austoin@example.com"}
    c.JSON(200, user)
    
    // ========== 结构体标签 ==========
    // json:"name" - JSON中的字段名
    // omitempty - 为空时不输出
    // 忽略字段
    type User struct {
        ID       uint   `json:"id"`
        Username string `json:"username"`
        Password string `json:"-"` // 忽略此字段
    }
    
    // ========== 响应JSON字符串 ==========
    c.JSON(200, `{"message": "hello"}`)
})
```

**字符串响应：**

```go
router.GET("/string", func(c *gin.Context) {
    // 普通字符串
    c.String(200, "Hello, World!")
    
    // 格式化字符串
    c.String(200, "用户: %s, 年龄: %d", "austoin", 25)
    
    // HTML
    c.String(200, "<html><body><h1>Hello</h1></body></html>")
})
```

**其他响应格式：**

```go
router.GET("/responses", func(c *gin.Context) {
    // ========== XML响应 ==========
    c.XML(200, gin.H{"message": "success"})
    
    // ========== YAML响应 ==========
    c.YAML(200, gin.H{"message": "success"})
    
    // ========== ProtoBuf响应 ==========
    // 需要定义 .proto 文件
    // c.ProtoBuf(200, &proto.Message{})
    
    // ========== Data响应 ==========
    // 第一个参数：状态码
    // 第二个参数：数据
    // 第三个参数：Content-Type
    c.Data(200, "text/plain; charset=utf-8", []byte("hello"))
    
    // ========== File响应 ==========
    // c.File("path/to/file.txt")
    
    // ========== FileAttachment响应 ==========
    // 强制下载
    // c.FileAttachment("path/to/file.txt", "download.txt")
    
    // ========== JSONP响应 ==========
    // 跨域请求
    // callback := c.Query("callback")
    // c.JSONP(200, gin.H{"message": "hello"})
})
```

**重定向：**

```go
router.GET("/redirect", func(c *gin.Context) {
    // ========== 301永久重定向 ==========
    c.Redirect(301, "http://example.com/new")
    
    // ========== 302临时重定向 ==========
    c.Redirect(302, "/new")
    
    // ========== 带数据的重定向 ==========
    // 需要用session或cookie传递数据
    c.Redirect(302, "/login?next=/profile")
})
```

**HTTP状态码：**

| 状态码 | 常量 | 说明 |
|-------|------|------|
| 200 | `http.StatusOK` | 成功 |
| 201 | `http.StatusCreated` | 创建成功 |
| 204 | `http.StatusNoContent` | 无内容 |
| 301 | `http.StatusMovedPermanently` | 永久重定向 |
| 302 | `http.StatusFound` | 临时重定向 |
| 400 | `http.StatusBadRequest` | 请求错误 |
| 401 | `http.StatusUnauthorized` | 未认证 |
| 403 | `http.StatusForbidden` | 无权限 |
| 404 | `http.StatusNotFound` | 未找到 |
| 500 | `http.StatusInternalServerError` | 服务器错误 |

---

### 13.9 路由分组

**分组基础：**

```go
// ========== 创建分组 ==========
v1 := router.Group("/api/v1")
{
    // 路由组内的路由会自动添加前缀 /api/v1
    v1.GET("/users", listUsers)
    v1.POST("/users", createUser)
    v1.GET("/users/:id", getUser)
    v1.PUT("/users/:id", updateUser)
    v1.DELETE("/users/:id", deleteUser)
}

// ========== 嵌套分组 ==========
api := router.Group("/api")
{
    v1 := api.Group("/v1")
    {
        users := v1.Group("/users")
        {
            users.GET("/", listUsers)
            users.POST("/", createUser)
            users.GET("/:id", getUser)
        }
    }
}
// 最终路径：/api/v1/users, /api/v1/users/:id

// ========== 给分组添加中间件 ==========
admin := router.Group("/admin")
admin.Use(AuthMiddleware())  // admin组的所有路由都会经过认证
{
    admin.GET("/dashboard", dashboard)
    admin.GET("/users", listUsers)
    admin.GET("/settings", settings)
}

// ========== 分组继承 ==========
api := router.Group("/api")
{
    api.POST("/login", loginHandler)
}

v1 := api.Group("/v1")
{
    v1.GET("/users", listUsers)  // /api/v1/users
    v1.GET("/posts", listPosts)  // /api/v1/posts
}
```

---

### 13.10 中间件

**中间件定义：**

```go
// ========== Logger 中间件 ==========
func Logger() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 请求开始时间
        start := time.Now()
        
        // 2. 获取请求信息
        method := c.Request.Method
        path := c.Request.URL.Path
        query := c.Request.URL.RawQuery
        
        // 3. 处理请求
        c.Next()
        
        // 4. 请求结束后执行
        latency := time.Since(start)
        status := c.Writer.Status()
        
        // 5. 记录日志
        fmt.Printf("[%s] %s %s | %d | %v\n",
            time.Now().Format("2006-01-02 15:04:05"),
            method, path+"?"+query, status, latency)
    }
}

// ========== 认证中间件 ==========
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 获取token
        token := c.GetHeader("Authorization")
        
        // 2. 验证token
        if token == "" {
            c.AbortWithStatusJSON(401, gin.H{
                "error": "需要认证",
            })
            return
        }
        
        // 3. 简化验证（实际应使用JWT验证）
        if token != "Bearer mytoken123" {
            c.AbortWithStatusJSON(401, gin.H{
                "error": "无效的token",
            })
            return
        }
        
        // 4. 验证通过，设置用户信息
        c.Set("user_id", 1)
        c.Set("username", "admin")
        
        // 5. 继续处理请求
        c.Next()
    }
}

// ========== 跨域中间件 ==========
func CorsMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 设置响应头
        c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
        c.Writer.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS")
        c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        c.Writer.Header().Set("Access-Control-Max-Age", "86400")
        
        // 处理OPTIONS预检请求
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    }
}

// ========== Limiter 中间件 ==========
// 限流中间件（简化版）
func RateLimitMiddleware() gin.HandlerFunc {
    // 使用 token bucket 算法
    // 实际可使用 golang.org/x/time/rate
    return func(c *gin.Context) {
        // 获取客户端IP
        ip := c.ClientIP()
        
        // 检查IP是否超过限制
        // 实际实现需要计数和过期时间
        
        c.Next()
    }
}
```

**中间件方法详解：**

```go
func exampleMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // ========== c.Next() ==========
        // 暂停当前中间件，执行下一个处理函数
        // 下一个函数执行完后，会继续执行当前中间件剩余代码
        fmt.Println("中间件开始")
        c.Next()
        fmt.Println("中间件结束")
        
        // ========== c.Abort() ==========
        // 阻止继续执行
        // 后续的中间件和路由处理器都不会执行
        c.Abort()
        
        // ========== c.AbortWithStatus() ==========
        // 阻止执行并返回指定状态码
        c.AbortWithStatus(401)
        
        // ========== c.AbortWithStatusJSON() ==========
        // 阻止执行并返回JSON
        c.AbortWithStatusJSON(401, gin.H{"error": "Unauthorized"})
        
        // ========== c.AbortWithError() ==========
        // 阻止执行并返回错误
        c.AbortWithError(500, err)
        
        // ========== c.Set() ==========
        // 设置值，后续中间件和处理器可以获取
        c.Set("user_id", 1)
        c.Set("user", &User{ID: 1})
        
        // ========== c.Get() ==========
        // 获取值，返回(value, exists)
        userId, exists := c.Get("user_id")
        if !exists {
            userId = 0
        }
        
        // ========== c.GetString() ==========
        username := c.GetString("username")
        
        // ========== c.GetInt() ==========
        userId := c.GetInt("user_id")
        
        // ========== c.GetBool() ==========
        isAdmin := c.GetBool("is_admin")
        
        // ========== c.Copy() ==========
        // 复制Context（用于goroutine中）
        cCp := c.Copy()
        go func() {
            // 在goroutine中使用
            _ = cCp
        }()
        
        // ========== c.Request ==========
        // 原始http.Request对象
        method := c.Request.Method
        url := c.Request.URL
        body := c.Request.Body
        
        // ========== c.Writer ==========
        // 响应Writer
        status := c.Writer.Status()
        size := c.Writer.Size()
    }
}
```

**中间件执行顺序：**

```go
// 全局中间件 -> 路由组中间件 -> 路由中间件 -> 处理器
router.Use(Middleware1()) // 1. 全局1
router.Use(Middleware2()) // 2. 全局2

admin := router.Group("/admin")
admin.Use(Middleware3()) // 3. 路由组中间件

admin.GET("/dashboard", Middleware4(), func(c *gin.Context) {
    // 4. 路由中间件
    // 5. 处理器
})
```

---

### 13.11 gin.Context 完整方法

**请求相关：**

```go
// ========== 参数获取 ==========
c.Param(key string) string                    // 路径参数
c.Query(key string) string                    // 查询参数
c.DefaultQuery(key, defaultValue string) string  // 带默认值
c.GetQuery(key string) (string, bool)         // 返回值+是否存在
c.QueryArray(key string) []string             // 同名多个值
c.QueryMap(key string) map[string]string      // Map参数
c.PostForm(key string) string                  // 表单参数
c.DefaultPostForm(key, defaultValue string) string  // 带默认值
c.GetPostForm(key string) (string, bool)      // 返回值+是否存在
c.FormFile(name string) (*multipart.File, *multipart.FileHeader, error)  // 文件
c.MultipartForm() (*multipart.Form, error)    // 整个表单
c.Header(key string) string                   // Header参数
c.GetHeader(key string) string               // Header参数（同Header）
c.Cookie(name string) string                  // Cookie
c.Request                                     // 原始Request

// ========== 绑定 ==========
c.ShouldBind(interface{}) error              // 自动选择绑定方式
c.ShouldBindJSON(interface{}) error            // JSON
c.ShouldBindQuery(interface{}) error          // Query
c.ShouldBindUri(interface{}) error             // URI
c.ShouldBindHeader(interface{}) error         // Header
c.ShouldBindWith(interface{}, binding.Binding) error  // 指定方式

// ========== 绑定验证（失败返回400） ==========
c.Bind(interface{}) error
c.BindJSON(interface{}) error
c.BindQuery(interface{}) error
c.BindUri(interface{}) error
c.BindHeader(interface{}) error
```

**响应相关：**

```go
// ========== 状态码 ==========
c.Status(code int)                            // 设置状态码
c.Writer                                      // http.ResponseWriter

// ========== JSON ==========
c.JSON(code int, obj interface{})             // JSON响应
c.AsciiJSON(code int, obj interface{})       // ASCII JSON
c.PureJSON(code int, obj interface{})        // 原生JSON（不转义）
c.SecureJSON(code int, obj interface{})      // 安全JSON

// ========== 其他格式 ==========
c.String(code int, format string, values ...interface{})  // 字符串
c.XML(code int, obj interface{})              // XML
c.YAML(code int, obj interface{})              // YAML
c.ProtoBuf(code int, obj interface{})          // ProtoBuf
c.Data(code int, contentType string, data []byte)  // 原始数据
c.File(filepath string)                         // 文件
c.FileAttachment(filepath, filename string)    // 强制下载
c.DataFromReader(code int, contentLength int64, contentType string, reader io.Reader, extraHeaders map[string]string)  // 流式响应

// ========== 重定向 ==========
c.Redirect(code int, location string)

// ========== HTML ==========
c.HTML(code int, name string, obj interface{})  // 渲染HTML模板
c.Render(code int, r render.Render)             // 自定义渲染
c.LoadHTMLGlob(pattern string)                   // 加载HTML文件
c.LoadHTMLFiles(files ...string)                 // 加载HTML文件列表
c.Delims(left, right string)                     // 设置模板分隔符
c.SetFuncMap(funcMap template.FuncMap)          // 设置模板函数
```

**中间件控制：**

```go
c.Next()                                       // 继续执行
c.Abort()                                      // 阻止继续
c.AbortWithStatus(code int)                    // 阻止并返回状态码
c.AbortWithStatusJSON(code int, obj interface{}) // 阻止并返回JSON
c.AbortWithError(code int, err error)          // 阻止并返回错误

// ========== 数据传递 ==========
c.Set(key string, value interface{})           // 设置值
c.Get(key string) (value interface{}, exists bool)
c.GetString(key string) string
c.GetInt(key string) int
c.GetBool(key string) bool
c.GetFloat(key string) float64
c.GetTime(key string) time.Time
c.GetDuration(key string) time.Duration
c.GetStringMap(key string) map[string]interface{}
c.GetStringMapString(key string) map[string]string
c.GetStringMapStringSlice(key string) []string

// ========== 其他 ==========
c.Copy() *Context                               // 复制Context
c.Error(err error) *error.Error                 // 设置错误
c.Errors *error.Errors                          // 错误列表
c.Handler() HandlerFunc                         // 当前处理器
c.HandlerName() string                         // 处理器名称
c.HandlerStack() []HandlerFunc                  // 整个处理器栈
c.Keys map[string]interface{}                   // 所有设置的键值
c.Request                                      // 原始请求
c.Writer http.ResponseWriter                    // 响应Writer
```

---

### 13.12 404处理

```go
// ========== NoRoute ==========
// 处理没有匹配到路由的情况
router.NoRoute(func(c *gin.Context) {
    c.JSON(404, gin.H{
        "error":  "页面未找到",
        "path":   c.Request.URL.Path,
        "method": c.Request.Method,
    })
})

// ========== NoMethod ==========
// 处理不支持的HTTP方法
router.NoMethod(func(c *gin.Context) {
    c.JSON(405, gin.H{
        "error":   "不支持的请求方法",
        "method":  c.Request.Method,
        "support": []string{"GET", "POST", "PUT", "DELETE"},
    })
})

// ========== 自定义404页面 ==========
router.LoadHTMLGlob("templates/*")
router.NoRoute(func(c *gin.Context) {
    c.HTML(404, "404.html", gin.H{
        "title": "页面未找到",
    })
})
```

---

### 13.13 静态文件服务

```go
// ========== 静态目录 ==========
// 访问 /static/css/style.css
// 实际读取 ./public/css/style.css
router.Static("/static", "./public")

// ========== 单个文件 ==========
// 访问 /favicon.ico
// 返回 ./public/favicon.ico
router.StaticFile("/favicon.ico", "./public/favicon.ico")

// ========== 多个文件 ==========
router.StaticFile("/logo.png", "./public/logo.png")
router.StaticFile("/robots.txt", "./public/robots.txt")

// ========== HTML模板 ==========
// 加载模板
router.LoadHTMLGlob("templates/*")
// 或
router.LoadHTMLFiles("templates/index.html", "templates/about.html")

// 渲染模板
router.GET("/page", func(c *gin.Context) {
    c.HTML(200, "index.html", gin.H{
        "title": "首页",
        "name":  "Austoin",
    })
})

// 设置模板函数
router.SetFuncMap(template.FuncMap{
    "upper": strings.ToUpper,
    "lower": strings.ToLower,
})

// 模板中可以使用 {{ upper .name }}
```

---

### 13.14 文件上传

```go
router.POST("/upload", func(c *gin.Context) {
    // ========== 单个文件 ==========
    file, err := c.FormFile("file")
    if err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
    
    // file.Filename - 原始文件名
    // file.Size - 文件大小（字节）
    // file.Header - 文件头信息
    
    // 保存文件
    filename := fmt.Sprintf("./uploads/%d_%s", time.Now().Unix(), file.Filename)
    if err := c.SaveUploadedFile(file, filename); err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(200, gin.H{
        "message":  "上传成功",
        "filename": file.Filename,
        "size":     file.Size,
    })
    
    // ========== 多个文件 ==========
    form, err := c.MultipartForm()
    if err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
    
    files := form.File["files[]"]
    for _, file := range files {
        // 处理每个文件
        _ = file
    }
    
    // ========== 限制文件大小 ==========
    // router.MaxMultipartMemory = 8 << 20  // 8MB
})
```

---

### 13.15 完整代码结构

```
Lesson12()
├── Lesson12()           // 主函数，创建路由器并启动
├── basicDemo()          // GET/POST/PUT/DELETE 基础路由
├── paramDemo()          // 路径参数、查询参数、Header、表单
├── jsonDemo()           // JSON绑定和验证
├── groupDemo()          // 路由分组
├── middlewareDemo()     // 中间件
├── Logger()             // 日志中间件
├── AuthMiddleware()     // 认证中间件
└── CorsMiddleware()     // 跨域中间件
```

---

### 13.16 运行命令

```bash
# 安装依赖
go get -u github.com/gin-gonic/gin
go mod tidy

# 运行
go run main.go

# 测试
# GET http://localhost:8080/
# GET http://localhost:8080/users/123
# GET http://localhost:8080/search?q=Gin&page=2
# POST http://localhost:8080/users (JSON body)
```

---

### 13.17 用户代码亮点

- ✅ 正确创建gin路由器（gin.Default）
- ✅ 正确使用GET/POST/PUT/DELETE方法
- ✅ 正确获取路径参数（c.Param）
- ✅ 正确获取查询参数（c.Query/c.DefaultQuery）
- ✅ 正确获取Header参数（c.GetHeader）
- ✅ 正确使用JSON绑定和binding标签验证
- ✅ 正确使用路由分组（Group）
- ✅ 正确创建和使用中间件
- ✅ 正确实现认证中间件（c.AbortWithStatusJSON）
- ✅ 正确实现跨域中间件（CorsMiddleware）
- ✅ 正确使用c.Set和c.Get传递数据
- ✅ 正确实现404处理（NoRoute）
- ✅ 正确处理表单参数（c.PostForm）
- ✅ 正确使用c.String和c.JSON响应

---

## 13、第12课Gin框架（已学完）

### 13.1 Gin框架简介

**是什么：** Gin是Go语言中最流行的Web框架，高性能、简单易用。

**特点：**
- 高性能（基于httprouter）
- 内存占用低
- 中间件机制强大
- API设计简洁

**安装：**
```bash
go get -u github.com/gin-gonic/gin
```

### 13.2 创建路由器

```go
// gin.Default() - 带默认中间件（Logger + Recovery）
router := gin.Default()

// gin.New() - 不带中间件
router := gin.New()
```

| 方式 | 说明 | 适用场景 |
|-----|------|---------|
| `gin.Default()` | 默认Logger + Recovery | 生产环境推荐 |
| `gin.New()` | 纯净版 | 需要自己配置中间件 |

### 13.3 HTTP方法与路由

```go
router.GET("/path", handler)     // 查询
router.POST("/path", handler)   // 创建
router.PUT("/path", handler)    // 更新
router.DELETE("/path", handler) // 删除
```

### 13.4 路径参数

| 类型 | 语法 | 获取方式 | 示例 |
|-----|------|---------|------|
| 路径参数 | `:name` | `c.Param("name")` | `/users/:id` |
| 通配符 | `*name` | `c.Param("name")` | `/files/*path` |

```go
// 路径参数
router.GET("/users/:id", func(c *gin.Context) {
    id := c.Param("id")
    c.String(http.StatusOK, "用户ID: %s", id)
})

// 多个路径参数
router.GET("/posts/:postId/comments/:commentId", func(c *gin.Context) {
    postId := c.Param("postId")
    commentId := c.Param("commentId")
})
```

### 13.5 查询参数

```go
router.GET("/search", func(c *gin.Context) {
    // c.Query() 获取，不存在返回空字符串
    q := c.Query("q")
    
    // c.DefaultQuery() 获取，不存在返回默认值
    page := c.DefaultQuery("page", "1")
    size := c.DefaultQuery("size", "10")
})
```

### 13.6 Header参数

```go
router.GET("/header", func(c *gin.Context) {
    token := c.GetHeader("Authorization")
    contentType := c.GetHeader("Content-Type")
})
```

### 13.7 JSON绑定与验证

```go
// 定义结构体，使用 binding 标签
type User struct {
    Username string `json:"username" binding:"required,min=3,max=20"`
    Email    string `json:"email" binding:"required,email"`
    Age      int    `json:"age" binding:"gte=0,lte=150"`
}

// 绑定JSON
router.POST("/users", func(c *gin.Context) {
    var user User
    
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusCreated, user)
})
```

**常用binding标签：**

| 标签 | 说明 | 示例 |
|-----|------|------|
| `required` | 必填 | `binding:"required"` |
| `min` | 最小值 | `binding:"min=3"` |
| `max` | 最大值 | `binding:"max=20"` |
| `email` | 邮箱格式 | `binding:"email"` |
| `gte` | 大于等于 | `binding:"gte=0"` |
| `lte` | 小于等于 | `binding:"lte=150"` |

### 13.8 响应

```go
// JSON响应
c.JSON(200, gin.H{"code": 0, "message": "success"})

// 字符串响应
c.String(200, "Hello World")

// JSON结构体响应
c.JSON(http.StatusOK, User{ID: 1, Username: "austoin"})
```

### 13.9 路由分组

```go
// 创建分组
v1 := router.Group("/api/v1")
{
    v1.GET("/users", usersHandler)
    v1.POST("/users", createUser)
    v1.GET("/users/:id", getUser)
}

// 嵌套分组
admin := router.Group("/admin")
admin.Use(AuthMiddleware())
{
    admin.GET("/dashboard", dashboard)
}
```

### 13.10 中间件

**是什么：** 处理请求的函数，在路由处理器之前/之后执行。

```go
// Logger 日志中间件
func Logger() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        // 处理请求
        c.Next()
        
        // 请求结束后执行
        latency := time.Since(start)
        status := c.Writer.Status()
        fmt.Printf("[%d] %s | %v\n", status, c.Request.URL.Path, latency)
    }
}

// 使用中间件
router.Use(Logger())  // 全局中间件
```

**中间件方法：**
- `c.Next()` - 继续执行下一个处理函数
- `c.Abort()` - 阻止继续执行
- `c.Set()` - 设置值
- `c.Get()` - 获取值

### 13.11 gin.Context 常用方法

| 方法 | 作用 | 示例 |
|-----|------|------|
| `c.Param("name")` | 获取路径参数 | `c.Param("id")` |
| `c.Query("name")` | 获取查询参数 | `c.Query("page")` |
| `c.DefaultQuery()` | 带默认值的查询参数 | `c.DefaultQuery("page", "1")` |
| `c.GetHeader("name")` | 获取Header | `c.GetHeader("Authorization")` |
| `c.ShouldBindJSON(&obj)` | 绑定JSON | |
| `c.JSON(status, obj)` | 返回JSON | `c.JSON(200, user)` |
| `c.String(status, msg)` | 返回字符串 | `c.String(200, "hello")` |
| `c.Next()` | 继续执行 | |
| `c.Abort()` | 阻止继续 | |
| `c.Set(key, value)` | 设置值 | `c.Set("user_id", 1)` |
| `c.Get(key)` | 获取值 | `c.Get("user_id")` |

### 13.12 完整代码结构

```
Lesson12()
├── Lesson12()         // 主函数，创建路由器并启动
├── basicDemo()        // GET/POST/PUT/DELETE 基础路由
├── paramDemo()        // 路径参数、查询参数、Header
├── jsonDemo()         // JSON绑定和验证
├── groupDemo()        // 路由分组
├── middlewareDemo()   // 中间件
├── Logger()           // 日志中间件
├── AuthMiddleware()   // 认证中间件
└── CorsMiddleware()   // 跨域中间件
```

### 13.13 运行命令

```bash
# 安装依赖
go get -u github.com/gin-gonic/gin
go mod tidy

# 运行
go run main.go

# 测试
# 浏览器访问 http://localhost:8080/
# http://localhost:8080/users/123
# http://localhost:8080/search?keyword=Gin&page=2
```

### 13.14 用户代码亮点

- ✅ 正确创建gin路由器（gin.Default）
- ✅ 正确使用GET/POST/PUT/DELETE方法
- ✅ 正确获取路径参数（c.Param）
- ✅ 正确获取查询参数（c.DefaultQuery）
- ✅ 正确获取Header参数（c.GetHeader）
- ✅ 正确使用JSON绑定和binding标签验证
- ✅ 正确使用路由分组（Group）
- ✅ 正确创建和使用中间件
- ✅ 正确实现认证中间件（c.AbortWithStatusJSON）
- ✅ 正确实现跨域中间件（CorsMiddleware）
- ✅ 正确使用c.Set和c.Get传递数据

- Go官方模块文档：https://golang.org/ref/mod
- Go模块命令：https://golang.org/cmd/go/#hdr-Module_maintenance
