# Go模块管理笔记

> 记录日期：2026-02-06
> 适用场景：本地开发、跨目录模块调用

---

## 一、核心概念

### 1.1 模块（Module）是什么？

**模块 = 项目 = 一个 `go.mod` 文件**

| 概念 | 说明 |
|-----|------|
| 模块 | Go依赖管理的基本单位 |
| go.mod | 模块声明文件，记录模块名、版本、依赖 |
| go.sum | 依赖校验文件，确保依赖1.2 包安全 |

### （Package）是什么？

**包 = 目录 = 一组 `.go` 文件**

| 规则 | 说明 |
|-----|------|
| 同一目录 | 同一包，直接调用 |
| 不同目录 | 不同包，需要导入 |
| 包名 | 目录名或自定义，通常与目录名一致 |

---

## 二、本地模块开发

### 2.1 问题背景

正常情况下，Go期望从**远程仓库**下载模块：
```
import "github.com/用户名/项目名/子目录"
```

但开发阶段代码在**本地**，没有上传GitHub。

### 2.2 解决方案：replace 指令

**作用**：告诉Go"这个模块虽然在远程路径里，但实际上在本地"

#### 配置步骤

**步骤1：根目录执行初始化（只需一次）**
```bash
cd GolangTutorial
go mod init github.com/austoin/golangtutorial
```

**步骤2：在go.mod中添加replace指令**
```go
module github.com/austoin/golangtutorial

go 1.25.6

replace 远程路径 => 本地路径
```

**步骤3：编写调用代码**
```go
package main

import (
    别名 "远程路径"
)

func main() {
    别名.公开函数()
}
```

---

## 三、实战：austoinDemo/A-base 调用示例

### 3.1 目录结构

```
GolangTutorial/
├── go.mod                    ← 根模块
│
├── austoinDemo/
│   ├── main.go               ← 主程序（调用方）
│   └── A-base/               ← 子包（被调用方）
│       ├── 1.go
│       ├── 2.go
│       └── ...
```

### 3.2 被调用方：A-base/*.go

```go
// A-base/1.go
package lesson  // 包名

func Lesson1() {  // 首字母大写 = 公开，可被其他包访问
    fmt.Println("Hello, World!")
}
```

**关键点**：
- 包名：`lesson`（与目录名无关，可自定义）
- 函数名：`Lesson1()` 首字母大写（公开）
- 同目录下其他文件也需要 `package lesson`

### 3.3 调用方：main.go

```go
// austoinDemo/main.go
package main

import (
    abaselib "github.com/austoin/golangtutorial/austoinDemo/A-base"
)

func main() {
    abaselib.Lesson1()
}
```

**关键点**：
- 导入路径 = 模块路径 + 子目录路径
- 使用别名避免冲突：`abaselib` 是别名
- 调用方式：`别名.公开函数()`

### 3.4 根目录：go.mod

```go
module github.com/austoin/golangtutorial

go 1.25.6

replace github.com/austoin/golangtutorial/austoinDemo/A-base => ./austoinDemo/A-base
```

**关键点**：
- `replace` 指令将远程路径映射到本地路径
- `=>` 左边是远程路径，右边是本地路径

---

## 四、远程模块调用

### 4.1 调用第三方库

```go
package main

import (
    "github.com/gin-gonic/gin"  // Web框架
    "gorm.io/gorm"              // ORM库
    "github.com/redis/go-redis/v9"  // Redis客户端
)

func main() {
    // 使用第三方库
    r := gin.Default()
    r.GET("/", func(c *gin.Context) {
        c.String(200, "Hello!")
    })
    r.Run()
}
```

### 4.2 下载依赖

```bash
go mod tidy
```

**作用**：
1. 扫描代码中的 `import`，识别使用的依赖
2. 下载依赖到本地
3. 自动更新 `go.mod` 和 `go.sum`

---

## 五、go.mod 详解

### 5.1 最小配置

```go
module 模块名

go 版本号
```

### 5.2 完整配置

```go
module github.com/用户名/项目名

go 1.25.6

require (
    第三方库1 v1.0.0
    第三方库2 v2.0.0
)

replace 本地路径 => 远程路径

replace 本地路径 => ./本地子目录
```

### 5.3 常用命令

| 命令 | 作用 |
|-----|------|
| `go mod init 模块名` | 初始化模块（创建go.mod） |
| `go mod tidy` | 下载依赖，更新go.mod/go.sum |
| `go mod download` | 下载所有依赖 |
| `go get 包名@版本` | 下载指定包 |
| `go env -w GOPROXY=...` | 设置代理（国内用goproxy.cn） |

---

## 六、常见问题

### Q1: 相对路径导入报错？

**错误**：
```
local import "./A-base" in non-local package
```

**原因**：Go 1.16+ 不支持相对路径导入

**解决**：使用模块路径 + replace 指令

### Q2: ambiguous import？

**错误**：
```
found package in multiple modules
```

**原因**：
- 模块在主模块和子模块中都存在
- 重复的 require 声明

**解决**：
1. 删除子目录的独立 go.mod
2. 清理根目录 go.mod 中多余的 require

### Q3: 找不到包？

**错误**：
```
cannot find package
```

**原因**：
- 没有运行 `go mod tidy`
- replace 路径错误

**解决**：
```bash
go mod tidy
# 检查 replace 路径是否正确
```

---

## 七、可见性规则

### 7.1 函数/变量可见性

```go
package lesson

func PublicFunc() {}    // ✅ 首字母大写 = 公开，其他包可访问

func privateFunc() {}   // ❌ 首字母小写 = 私有，其他包不可访问
```

### 7.2 结构体可见性

```go
package lesson

type PublicStruct struct {  // ✅ 公开
    Name string  // 字段也可以控制可见性
}

type privateStruct struct {  // ❌ 私有
    age int
}
```

---

## 八、接口与隐式实现

### 8.1 什么是接口？

**接口 = 方法签名的集合**，定义对象应该具备什么行为。

```go
// 定义接口
type Introducer interface {
    Introduce() string  // 要求实现这个方法
}
```

### 8.2 隐式实现（Go的特性）

**在Go中，接口是隐式实现的**——不需要显式声明"我实现了这个接口"。

只要结构体拥有接口中定义的所有方法，它就**自动**实现了该接口。

```go
// 1. 定义接口
type Introducer interface {
    Introduce() string
}

// 2. 定义结构体
type Person struct {
    Name string
    Age  int
}

// 3. 结构体拥有接口要求的方法
func (p Person) Introduce() string {
    return fmt.Sprintf("我叫%s，今年%d岁", p.Name, p.Age)
}

// 4. 因此 Person 自动实现了 Introducer 接口
//    不需要像 Java 那样写：class Person implements Introducer
```

### 8.3 原理：鸭子类型

> "如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子"

```
Person 有 Introduce() 方法
        ↓
自动满足 Introducer 接口
        ↓
Person 的对象可以当作 Introducer 使用
```

### 8.4 接口的实际应用

```go
// 接口可以存储任何实现了该接口的类型
var greeter Introducer

p1 := Person{Name: "Eve", Age: 32}
greeter = p1  // ✅ 可以，因为 Person 实现了 Introducer

fmt.Printf("%s\n", greeter.Introduce())

// 遍历实现接口的对象
people := []Person{
    {Name: "Charlie", Age: 35},
    {Name: "Diana", Age: 28},
}

for _, p := range people {
    fmt.Printf("%s 说: %s\n", p.Name, p.Introduce())
}
```

### 8.5 空接口 interface{}

空接口可以存储**任意类型**：

```go
var anything interface{}

anything = 42
fmt.Printf("anything: %v\n", anything)  // 42

anything = "hello"
fmt.Printf("anything: %v\n", anything)  // hello

anything = []int{1, 2, 3}
fmt.Printf("anything: %v\n", anything)  // [1 2 3]
```

### 8.6 对比：显式 vs 隐式实现

| 语言 | 实现方式 |
|-----|---------|
| **Go** | 隐式（自动） |
| Java | 显式 (`class Person implements Introducer`) |
| TypeScript | 显式 (`class Person implements Introducer`) |

---

## 九、总结

### 开发流程

```
1. 创建项目
   go mod init 模块名

2. 创建子目录（存放可复用代码）
   新建目录，编写.go文件，包名自定义，函数首字母大写

3. 配置replace（本地开发）
   go.mod中添加 replace 指令

4. 调用子包
   main.go中使用 import 导入，使用 别名.函数() 调用

5. 运行
   go run main.go
```

### 关键规则

| 场景 | 包名 | 函数可见性 | 调用方式 |
|-----|------|-----------|---------|
| 同一目录 | 相同 | 大小写都可 | 直接调用 |
| 不同目录 | 不同 | 仅大写 | import + 别名.函数() |

---

## 九、Go基础语法核心概念（Lessons 1-8）

### 9.1 第1课：Hello World

| 概念 | 说明 | 示例 |
|-----|------|------|
| package | 包声明，每个文件必须属于一个包 | `package mybase` |
| import | 导入标准库 | `import "fmt"` |
| fmt.Println | 打印并换行 | `fmt.Println("Hello")` |
| fmt.Printf | 格式化输出 | `fmt.Printf("Name: %s\n", name)` |

### 9.2 第2课：变量声明

| 声明方式 | 语法 | 示例 |
|---------|------|------|
| var 完整声明 | `var 变量名 类型 = 值` | `var name string = "Austoin"` |
| 简短声明 | `变量名 := 值` | `city := "重庆"` |
| 常量 | `const 变量名 = 值` | `const pi = 3.14` |

### 9.3 第3课：基本数据类型

| 类型 | 说明 | 示例 |
|-----|------|------|
| 整型 | int, int8/16/32/64, uint | `var age int = 22` |
| 无符号 | uint, uint8/16/32/64 | `var savings uint = 100000` |
| 浮点型 | float32, float64 | `var height float64 = 1.75` |
| 布尔型 | true, false | `var isStudent bool = true` |
| 字符串 | UTF-8文本 | `var name string = "Austoin"` |

**零值**：
- int/float → 0
- bool → false
- string → ""

### 9.4 第4课：条件语句

| 语句 | 说明 | 示例 |
|-----|------|------|
| if | 单条件判断 | `if score >= 90 { ... }` |
| if-else | 双条件判断 | `if ... { } else { }` |
| if-else if | 多条件判断 | `if ... { } else if ... { } else { }` |
| switch | 多值匹配 | `switch day { case 1: ... }` |
| switch 多case | 合并条件 | `case 3,4,5: ...` |

### 9.5 第5课：循环语句

| 循环类型 | 说明 | 示例 |
|---------|------|------|
| for | 基础循环 | `for i := 0; i < 5; i++ { }` |
| while效果 | 省略初始化和增量 | `for i < 5 { i++ }` |
| for range | 遍历切片/映射 | `for index, value := range nums { }` |
| break | 退出循环 | `if i == 5 { break }` |
| continue | 跳过本次 | `if i == 3 { continue }` |

### 9.6 第6课：函数

| 特性 | 说明 | 示例 |
|-----|------|------|
| 基本函数 | 有参数有返回值 | `func add(a, b int) int { return a+b }` |
| 多返回值 | 返回多个值 | `func divide(a,b float64) (float64, error)` |
| 变长参数 | 接收任意数量参数 | `func sum(nums ...int) int { }` |
| 递归 | 函数调用自身 | `func factorial(n int) int { if n<=1 { return 1 }; return n*factorial(n-1) }` |

### 9.7 第7课：复合类型

| 数据结构 | 特点 | 关键操作 |
|---------|------|---------|
| **数组** | 固定长度，值类型 | `var arr [5]int` |
| **切片** | 动态长度，引用类型 | `s := []int{1,2,3}` |
| **映射** | 键值对，无序 | `m := map[string]int{}` |

**切片操作**：
- `append()` - 追加元素
- `make()` - 创建切片
- `len()`, `cap()` - 长度和容量
- 子切片 `[start:end]`

**映射操作**：
- 添加/修改：`m["key"] = value`
- 获取：`value, exists := m["key"]`
- 删除：`delete(m, "key")`

### 9.8 第8课：结构体和方法

| 概念 | 说明 | 示例 |
|-----|------|------|
| 结构体 | 自定义数据类型 | `type Person struct { Name string; Age int }` |
| 声明初始化 | 三种方式 | `p := Person{Name: "Austoin", Age: 22}` |
| 嵌套结构体 | 结构体包含结构体 | `type Student struct { Person; Score float64 }` |
| 值接收者 | 操作副本 | `func (p Person) GrowUp() { p.Age++ }` |
| 指针接收者 | 操作原值 | `func (p *Person) GrowUp() { p.Age++ }` |

### 9.9 核心语法速查表

| 类别 | 语法 | 说明 |
|-----|------|------|
| 变量 | `var x int` / `x := 10` | 声明/简短声明 |
| 常量 | `const PI = 3.14` | 编译期确定 |
| 条件 | `if/else`, `switch` | 流程控制 |
| 循环 | `for`, `for range` | 迭代 |
| 函数 | `func name(params) return {}` | 代码复用 |
| 数组 | `[5]int{1,2,3}` | 固定长度 |
| 切片 | `[]int{1,2,3}` | 动态数组 |
| 映射 | `map[string]int{}` | 键值对 |
| 结构体 | `struct { Name string }` | 自定义类型 |
| 方法 | `func (receiver Type) Method() {}` | 关联类型 |

---

## 十、参考文档

- Go官方模块文档：https://golang.org/ref/mod
- Go模块命令：https://golang.org/cmd/go/#hdr-Module_maintenance
