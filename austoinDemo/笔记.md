# Go模块管理笔记

> 记录日期：2026-02-06
> 适用场景：本地开发、跨目录模块调用

---

## 一、核心概念

### 1.1 模块（Module）是什么？

**模块 = 项目 = 一个 `go.mod` 文件**

| 概念 | 说明 |
|-----|------|
| 模块 | Go依赖管理的基本单位 |
| go.mod | 模块声明文件，记录模块名、版本、依赖 |
| go.sum | 依赖校验文件，确保依赖1.2 包安全 |

### （Package）是什么？

**包 = 目录 = 一组 `.go` 文件**

| 规则 | 说明 |
|-----|------|
| 同一目录 | 同一包，直接调用 |
| 不同目录 | 不同包，需要导入 |
| 包名 | 目录名或自定义，通常与目录名一致 |

---

## 二、本地模块开发

### 2.1 问题背景

正常情况下，Go期望从**远程仓库**下载模块：
```
import "github.com/用户名/项目名/子目录"
```

但开发阶段代码在**本地**，没有上传GitHub。

### 2.2 解决方案：replace 指令

**作用**：告诉Go"这个模块虽然在远程路径里，但实际上在本地"

#### 配置步骤

**步骤1：根目录执行初始化（只需一次）**
```bash
cd GolangTutorial
go mod init github.com/austoin/golangtutorial
```

**步骤2：在go.mod中添加replace指令**
```go
module github.com/austoin/golangtutorial

go 1.25.6

replace 远程路径 => 本地路径
```

**步骤3：编写调用代码**
```go
package main

import (
    别名 "远程路径"
)

func main() {
    别名.公开函数()
}
```

---

## 三、实战：austoinDemo/A-base 调用示例

### 3.1 目录结构

```
GolangTutorial/
├── go.mod                    ← 根模块
│
├── austoinDemo/
│   ├── main.go               ← 主程序（调用方）
│   └── A-base/               ← 子包（被调用方）
│       ├── 1.go
│       ├── 2.go
│       └── ...
```

### 3.2 被调用方：A-base/*.go

```go
// A-base/1.go
package lesson  // 包名

func Lesson1() {  // 首字母大写 = 公开，可被其他包访问
    fmt.Println("Hello, World!")
}
```

**关键点**：
- 包名：`lesson`（与目录名无关，可自定义）
- 函数名：`Lesson1()` 首字母大写（公开）
- 同目录下其他文件也需要 `package lesson`

### 3.3 调用方：main.go

```go
// austoinDemo/main.go
package main

import (
    abaselib "github.com/austoin/golangtutorial/austoinDemo/A-base"
)

func main() {
    abaselib.Lesson1()
}
```

**关键点**：
- 导入路径 = 模块路径 + 子目录路径
- 使用别名避免冲突：`abaselib` 是别名
- 调用方式：`别名.公开函数()`

### 3.4 根目录：go.mod

```go
module github.com/austoin/golangtutorial

go 1.25.6

replace github.com/austoin/golangtutorial/austoinDemo/A-base => ./austoinDemo/A-base
```

**关键点**：
- `replace` 指令将远程路径映射到本地路径
- `=>` 左边是远程路径，右边是本地路径

---

## 四、远程模块调用

### 4.1 调用第三方库

```go
package main

import (
    "github.com/gin-gonic/gin"  // Web框架
    "gorm.io/gorm"              // ORM库
    "github.com/redis/go-redis/v9"  // Redis客户端
)

func main() {
    // 使用第三方库
    r := gin.Default()
    r.GET("/", func(c *gin.Context) {
        c.String(200, "Hello!")
    })
    r.Run()
}
```

### 4.2 下载依赖

```bash
go mod tidy
```

**作用**：
1. 扫描代码中的 `import`，识别使用的依赖
2. 下载依赖到本地
3. 自动更新 `go.mod` 和 `go.sum`

---

## 五、go.mod 详解

### 5.1 最小配置

```go
module 模块名

go 版本号
```

### 5.2 完整配置

```go
module github.com/用户名/项目名

go 1.25.6

require (
    第三方库1 v1.0.0
    第三方库2 v2.0.0
)

replace 本地路径 => 远程路径

replace 本地路径 => ./本地子目录
```

### 5.3 常用命令

| 命令 | 作用 |
|-----|------|
| `go mod init 模块名` | 初始化模块（创建go.mod） |
| `go mod tidy` | 下载依赖，更新go.mod/go.sum |
| `go mod download` | 下载所有依赖 |
| `go get 包名@版本` | 下载指定包 |
| `go env -w GOPROXY=...` | 设置代理（国内用goproxy.cn） |

---

## 六、常见问题

### Q1: 相对路径导入报错？

**错误**：
```
local import "./A-base" in non-local package
```

**原因**：Go 1.16+ 不支持相对路径导入

**解决**：使用模块路径 + replace 指令

### Q2: ambiguous import？

**错误**：
```
found package in multiple modules
```

**原因**：
- 模块在主模块和子模块中都存在
- 重复的 require 声明

**解决**：
1. 删除子目录的独立 go.mod
2. 清理根目录 go.mod 中多余的 require

### Q3: 找不到包？

**错误**：
```
cannot find package
```

**原因**：
- 没有运行 `go mod tidy`
- replace 路径错误

**解决**：
```bash
go mod tidy
# 检查 replace 路径是否正确
```

---

## 七、可见性规则

### 7.1 函数/变量可见性

```go
package lesson

func PublicFunc() {}    // ✅ 首字母大写 = 公开，其他包可访问

func privateFunc() {}   // ❌ 首字母小写 = 私有，其他包不可访问
```

### 7.2 结构体可见性

```go
package lesson

type PublicStruct struct {  // ✅ 公开
    Name string  // 字段也可以控制可见性
}

type privateStruct struct {  // ❌ 私有
    age int
}
```

---

## 八、总结

### 开发流程

```
1. 创建项目
   go mod init 模块名

2. 创建子目录（存放可复用代码）
   新建目录，编写.go文件，包名自定义，函数首字母大写

3. 配置replace（本地开发）
   go.mod中添加 replace 指令

4. 调用子包
   main.go中使用 import 导入，使用 别名.函数() 调用

5. 运行
   go run main.go
```

### 关键规则

| 场景 | 包名 | 函数可见性 | 调用方式 |
|-----|------|-----------|---------|
| 同一目录 | 相同 | 大小写都可 | 直接调用 |
| 不同目录 | 不同 | 仅大写 | import + 别名.函数() |

---

## 九、参考文档

- Go官方模块文档：https://golang.org/ref/mod
- Go模块命令：https://golang.org/cmd/go/#hdr-Module_maintenance
